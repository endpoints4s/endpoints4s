# Algebras and interpreters

@@@ index
* [Endpoints](algebras/endpoints.md)
* [JSON entities](algebras/json-entities.md)
* [JSON schemas](algebras/json-schemas.md)
* [Chunked entities](algebras/chunked-entities.md)
* [Assets](algebras/assets.md)
* [Multiplexed endpoints](algebras/mux-endpoints.md)
* [Akka HTTP](interpreters/akka-http.md)
* [Play framework](interpreters/play.md)
* [http4s](interpreters/http4s.md)
* [Scala.js web client](interpreters/scalajs-web.md)
* [scalaj-http](interpreters/scalaj-http.md)
* [sttp](interpreters/sttp.md)
* [OpenAPI documentation](interpreters/openapi.md)
* [circe codecs](interpreters/circe.md)
* [Play JSON codecs](interpreters/play-json.md)
@@@

In *endpoints*, we call “algebra interfaces” (or just **algebras**) the
traits that provide methods for constructing and combining descriptions
of endpoints. You can find more details about the design of these
algebras in the @ref[Design in a nutshell](design.md) page.

The concepts defined by algebras are given a concrete meaning by **interpreters**.
In practice, we have three kinds of interpreters:

- **clients** building requests (their URL, headers and entity) and decoding responses,
- **servers** decoding requests and building responses,
- **documentation** in a machine-readable format.

## Naming conventions

- algebras are defined as traits in the `endpoints.algebra` package ;
    - e.g. the @scaladoc[`endpoints.algebra.Urls`](endpoints.algebra.Urls) trait defines
      an algebra for describing URLs.
- algebras’ dependencies can be found in their super types ;
- interpreters are traits that have the same name as the algebra they
  implement (they can be found by looking at the “known subclasses”
  of an algebra, in the Scaladoc) ;
    - e.g. the @scaladoc[`endpoints.play.client.Urls`](endpoints.play.client.Urls) trait
      defines a Play-based interpreter for the `Urls` algebra.
- compatible interpreters are in the same package ;
  - e.g. the @scaladoc[`endpoints.play.client`](endpoints.play.client.index)
    package provides interpreters that are all based on
    [Play WS](https://github.com/playframework/play-ws) under the hood.

## Matching Algebras and Interpreters

To define endpoint descriptions you need to select which algebras you
need. For instance:
 
~~~ scala
import endpoints.algebra

trait MyCustomAlgebra extends algebra.Endpoints
  with algebra.JsonEntitiesFromSchemas
  with algebra.BasicAuthentication
~~~

Then, to interpret the endpoint descriptions you need to build an
interpreter that matches this algebra. By following the aforementioned
naming conventions, you should be looking for all the traits that
have the same names as your algebra modules and that are in the package
of the interpreter you want to use. For instance, to build an Akka-HTTP
server:

~~~ scala
import endpoints.akkahttp.server

trait MyAkkaHttpServer extends MyCustomAlgebra
  with server.Endpoints
  with server.JsonEntitiesFromSchemas
  with server.BasicAuthentication
~~~

@@@ warning
If you try to mix an interpreter module that doesn’t match your algebra
the compiler will raise “conflicting inherited members” errors.
@@@

## Algebras

Algebras form a **hierarchy**: it is possible to extend an algebra
with additional vocabulary, or to mix several algebras together
to merge their vocabulary. This hierarchy can be seen in the
@scaladoc[diagram](endpoints.algebra.index#inheritance-diagram-container)
generated by the API documentation.

The following table lists the available algebras and points to their documentation.
You should start by reading the documentation of the `Endpoints` algebra, and the
documentation of the `JsonEntities` and `JsonSchemas` algebras if you want to
work with JSON.

| Name | Description |
|---|---|
|@ref[Endpoints](algebras/endpoints.md)|HTTP endpoints|
|@ref[JsonEntities](algebras/json-entities.md)|JSON request and response entities|
|@ref[JsonSchemas](algebras/json-schemas.md)|JSON schemas of data types|
|@ref[ChunkedEntities](algebras/chunked-entities.md)|Streamed requests and responses|
|@ref[Assets](algebras/assets.md)|Asset segments, endpoints serving fingerprinted assets|
|@ref[MuxEndpoints](algebras/mux-endpoints.md)|Multiplexed HTTP endpoints|

## Interpreters

Interpreters give a concrete meaning to the vocabulary and operations provided
by the algebras. They usually rely on other libraries (e.g. circe, Akka HTTP, etc.)
to do so. Pick the interpreters that fit your existing stack!

| Family | Description |
|---|---|
|@ref[Akka HTTP](interpreters/akka-http.md)|Client and server backed by [Akka HTTP](https://doc.akka.io/docs/akka-http/current/)|
|@ref[Play framework](interpreters/play.md)|Client and server backed by [Play framework](https://www.playframework.com/)|
|@ref[http4s](interpreters/http4s.md)|Server backed by [http4s](https://http4s.org)|
|@ref[Scala.js web](interpreters/scalajs-web.md)|Scala.js web client using `XMLHttpRequest`|
|@ref[scalaj-http](interpreters/scalaj-http.md)|JVM client backed by [scalaj-http](https://github.com/scalaj/scalaj-http)|
|@ref[sttp](interpreters/sttp.md)|JVM client backed by [sttp](https://github.com/softwaremill/sttp)|
|@ref[OpenAPI](interpreters/openapi.md)|Generates [OpenAPI](https://github.com/OAI/OpenAPI-Specification) documents for endpoints definitions|
|@ref[circe](interpreters/circe.md)|Builds [circe](http://circe.github.io/circe/) codecs out of JSON schema definitions|
|@ref[Play JSON](interpreters/play-json.md)|Builds [Play JSON](https://github.com/playframework/play-json) Reads and Writes out of JSON schema definitions|

@@@note
You can have different stacks on the client-side and the server-side. For instance,
you can have a server backed by Play framework, a client backed by Akka HTTP, and another
client backed by Scala.js (for web browsers).
@@@
